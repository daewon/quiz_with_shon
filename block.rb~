require 'set'

R, C = 3, 7
M = """#.....#
#.....#
##..###""".split("\n").map {|line| line.split('')}

# M = """##########
# #........#
# #........#
# #........#
# #........#
# #........#
# #........#
# ##########""".split("\n").map {|line| line.split('')}
# R, C = 8, 10

show = -> { puts M.map {|line| line.join('')} }
def generate r, c
  [[[r, c+1], [r+1, c]], [[r, c-1], [r+1, c]],
   [[r, c-1], [r+1, c-1]], [[r, c+1], [r+1, c+1]],
   [[r, c+1], [r-1, c]], [[r, c-1], [r-1, c]],
   [[r, c-1], [r-1, c-1]], [[r, c+1], [r-1, c+1]]]
    .map { |line| line << [r, c] }
    .select { |line| line.all? { |(r, c)|
      r >= 0 and c >= 0 and c < C and r < R and M[r][c] != '#'
    }
  }
end

S = Set.new
place = -> ch, pos { pos.each { |(r, c)| M[r][c] = ch } }

run = ->  do
  show.call
  if M.all? { |line| line.all? { |c| c == '#'} }
    # p "-" * 60
    # show.call
  end
  start_r, start_c = -1, -1
  catch :err do
    (0...R).each { |r|

      (0...C).each { |c|
        if M[r][c] == '.'
          start_r = r
          start_c = c
          throw :err
        end
      }
    }
  end
  p "#{start_r}, #{start_c}"
  if start_r == -1 and start_c == -1
    p "-" * 50
    show.call
    return
  end

  poses = generate(start_r, start_c)
  p poses
  poses.each { |pos|
    place.call '#', pos
    run.call
    place.call '.', pos
  }
end

run.call
